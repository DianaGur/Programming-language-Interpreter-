# -----------------------------------------Class Functions-----------------------------------------------

class ProgMem:

    """
    This class represents the program memory for the interpreter.
    It manages variables, operators, and control flow constructs.
    """
    
    def __init__(self):
        self.memory = {}  # var dictionary
        self.stack = []  # First cartridge that contains operators

        self.printable = True

        self.equals_operator = '='
        self.t_math_operators = ('+', '-', '*', '/')
        self.t_condition_operators = ('==', '>', '<')

        self.condition_key_words = ('if', 'while', 'then')
        self.condition_flag = False  # Track the nested conditions up to 3 levels
        self.track_condition = 0

        self.loop_flag = False  # Track the nested loops up to 3 levels
        self.track_loop = 0

    def get_variable(self, variable):  # TODO: need to handled if variable is not found
        """
            Get the value of a variable from the program memory.
            Parameters:
            variable (str): The name of the variable to retrieve.
            Returns:
            The value of the variable if found, False otherwise.
        """
        # check if empty:
        if len(self.memory.keys()) == 0:
            print("Could not find variable in the program memory")
            return False

        # check if wanted variable exist:
        for var in self.memory.keys():
            if var == variable:
                return self.memory.get(var)

        # TODO: ALTERNATIVE TO FOR LOOP: #
        # if variable in self.memory:
        #     return self.memory[variable]
        # else:
        #     print("Could not find variable '{}' in the program memory".format(variable))
        #     return False

        # if didn't find the wanted variable:
        print("Could not find variable in the program memory")
        return False

    def insert_variable(self, variable, value):

        for letter in self.memory.keys():
            if letter == variable:
                self.memory.pop(letter)
                self.memory.update({variable: value})  # updates existed value in the memory
                return True

        if len(self.memory.keys()) == 10:
            print("Maximum amount of variables has been reached")
            return False
        else:
            self.memory.update({variable: value})  # insert new value to the memory
            return True

    def find_operator(self, operator):
        for c in self.t_math_operators:
            if c == operator:
                return True

        return False

    def find_condition_operator(self, symbol):
        for operator in self.t_condition_operators:
            if operator == symbol:
                return True

        return False

    def naming_validation(self, ):  # TODO: checks the first part of expression until the '='
        pass

# -----------------------------------------Main Functions-----------------------------------------------


def is_valid(inpt):  # TODO: we need to think if we want to stop program with error or keep going
    """
        Check if the input string meets certain criteria.

        Parameters:
        inpt(str): The input string to be validated.

        Raises:
        SyntaxError: If the input is empty, has a length greater than or equal to 30 characters,
                     or has an unbalanced number of parentheses.

        Returns: None
    """

    # checks bounds of  the string input
    if len(inpt) == 0:
        raise SyntaxError('Unexpected EOF while parsing')
    if len(inpt) >= 100:
        raise SyntaxError('Unsuitable length of the input, length should be less than 100 chars')

    # checks consistency with brackets:
    counter = 0
    for char in inpt:
        if char == '(':
            counter += 1
        if char == ')':
            counter -= 1

    # if inconsistent:
    if counter != 0:
        raise SyntaxError('Unbalanced number of brackets')


def tokenize(inpt):
    """
    Tokenize a string by splitting it into words and removing parentheses.

    Parameters:
    code (str): The input string to be tokenized.

    Returns:
    list: A list of tokens extracted from the input string.
    """

    # - TODO: for handling space issues:
    # char_list = []
    # for char in inpt:
    #     if char not in '() ':
    #         char_list.append(char)
    # return char_list

    return inpt.replace('(', '').replace(')', '').split()


def logic_exp(exp_logic, c):
    """
    Calculate the result of a logical expression from a list of strings.

    Parameters:
    exp_logic (list): List of strings representing the logical expression.
    c (str): Comparison operator ('>', '<', '==').

    Returns:
    bool: Result of the logical expression.
    """

    memory.printable = False  # disable printing the calculation of the math result

    x = []
    y = []
    for i in range(len(exp_logic)):
        k = exp_logic.pop(0)
        if k == c:
            break
        x.append(k)

    y = exp_logic.copy()

    if len(x) > 1:
        part1 = int(classifier(x))
    else:
        part1 = x.pop(0)
        if part1.isdigit():
            part1 = int(part1)
        else:
            part1 = memory.get_variable(part1)

    # part 1 is None?
    if len(y) > 1:
        part2 = int(classifier(y))
    else:
        part2 = y.pop(0)
        if part2.isdigit():
            part2 = int(part2)
        else:
            part2 = memory.get_variable(part2)

    memory.printable = True
    if c == '>':
        print(part1 > part2)
        return part1 > part2
    elif c == '<':
        print(part1 < part2)
        return part1 < part2
    elif c == '==':
        print(part1 == part2)
        return part1 == part2

    return False


def calc_result(inpt):
    """
    Evaluate a math expression with prefix operators.

    Parameters:
    inpt (list): List of strings representing the expression.

    Returns:
    str or None: The result of the expression as a string, or None if there was an error.
    """

    while len(inpt) > 1:
        index = 0
        operation = ''
        for i in range(len(inpt) - 1, -1, -1):  # Search for the first operator for the end fo the list
            index = index - 1
            if memory.find_operator(inpt[i]):
                operation = inpt[i]
                break
        if inpt[index + 1].isdigit():  # get first number ofter the operator
            x = int(inpt[index + 1])
        else:
            x = memory.get_variable(inpt[index + 1])
            if x != False:
                x = int(x)
            else:
                return

        if inpt[index + 2].isdigit():  # get second number ofter the operator
            y = int(inpt[index + 2])
        else:
            y = int(memory.get_variable(inpt[index + 2]))
            if y != False:
                y = int(y)
            else:
                return

        if operation == '+':
            x = x + y
        elif operation == '-':
            x = x - y
        elif operation == '*':
            x = x * y
        elif operation == '/':
            x = x / y

        inpt.pop(index + 2)
        inpt.pop(index + 2)
        inpt.pop(index + 2)
        inpt.append(str(int(x)))  # Dealing with float numbers by converting them to int and then to string
    if memory.printable:
        print(inpt[0])
    return inpt.pop(0)


# Helper function to convert tokens to appropriate data types
def atom(token):
    """
       This function converts the given token into an appropriate atomic value.

       It tries to convert the token to an integer using int(token).
       If that fails (raises a ValueError), it tries to convert the token to a float using float(token).
       If that also fails (raises a ValueError), it returns the original token as a string.

       Parameters:
       token (str): The token to be converted.

       Returns:
       int or float or str: The converted atomic value.
    """

    try:
        return int(token)
    except ValueError:
        try:
            return float(token)
        except ValueError:
            return token


# Define the evaluator to execute Lisp expressions
def classifier(list_inpt):
    """
        Classify and handle different types of statements from the given input list.

        This function examines the first element of the input list and determines the type of statement:
        - If the first element is 'if', it calls the if_handler function to handle an if statement.
        - If the first element is 'while', it calls the while_handler function to handle a while loop.
        - Otherwise, it searches for significant characters ('>', '=', etc.) to classify the statement:
            - If found, it calls the logic_exp function to evaluate a logical expression.
            - If '=' is found, it calls the placement_handler function to handle variable assignment.
            - If none of the above, it assumes the statement is a math expression and calls calc_result.

        Parameters:
        list_inpt (list of str): A list of strings representing the statement.

        Returns:
        int or float or str or None: The result of the statement evaluation.
    """

    if list_inpt[0] == 'if':
        list_inpt.pop(0)  # Removes 'if' from the input list
        if_handler(list_inpt)

    elif list_inpt[0] == 'while':
        list_inpt.pop(0)  # Removes 'while' from the input list
        while_handler(list_inpt)

    else:

        for element in list_inpt:  # loop that searches for significant characters > =
            if memory.find_condition_operator(element):
                c = element
                print(logic_exp(list_inpt, c))
                return
            elif element == memory.equals_operator:
                placement_handler(list_inpt)
                return
        res = (calc_result(list_inpt))  # In case we have not found any significant characters, it is a math expression
        return res


def placement_handler(expression):  # [ '9']   identifier = [ 'a']
    """
        Handle variable assignment from a given expression.

        This function extracts the identifier and value parts from the given expression,
        calculates the value, and inserts the variable with its corresponding value into memory.

        Parameters:
        expression (list of str): A list of strings representing the assignment statement.
                                  The format should be [identifier, '=', value].

        Returns:
        None
    """

    memory.printable = False
    identifier = []
    for k in range(len(expression)):
        part = expression.pop(0)
        if part == '=':
            break
        identifier.append(part)

    identifier = str(identifier.pop(0))
    value = expression.copy()
    value = calc_result(value)
    memory.insert_variable(identifier, value)
    memory.printable = True


def if_handler(expression):
    """
        Handle the 'if' statement from the given expression.

        This function extracts the condition and body parts from the given expression,
        evaluates the condition, and executes the body if the condition is true.

        Parameters:
        expression (list of str): A list of strings representing the 'if' statement.
                                  The format should be ['if', condition, 'then', body].

        Returns:
        None
    """

    condition = []
    c = ' '
    for i in range(len(expression)):
        part = expression.pop(0)
        if part == 'then':
            break
        elif memory.find_condition_operator(part):
            c = part
            condition.append(part)
        else:
            condition.append(part)
    print(condition)
    body = expression.copy()
    print(body)
    if logic_exp(condition, c):
        classifier(body)
    else:
        return print("-")  # indication hasnt enter the if


def while_handler(inpt):
    """
        Handle the 'while' loop from the given input.

        This function extracts the condition and body parts from the given input,
        evaluates the condition, and repeatedly executes the body as long as the condition is true.

        Parameters:
        inpt (list of str): A list of strings representing the 'while' loop.
                            The format should be [condition, ':', body].

        Returns:
        None
    """

    condition = []
    c = ' '
    for part in inpt:
        if part == ':':
            break
        elif memory.find_condition_operator(part):
            c = part
            condition.append(part)
        else:
            condition.append(part)
        inpt.pop(0)
    print(condition)
    body = inpt.copy()
    inpt.clear()
    while logic_exp(condition, c):
        classifier(body)
    return print("end")  # indication for finishing the

# ------------------------------------------------Main-------------------------------------------------------
# if __name__ == '__main__':


memory = ProgMem()  # consider to make a global var
while True:
    str_inpt = input(">>>")

    if str_inpt == 'close':  # Ends the program
        exit(0)
    # ALTERNATIVE: adding or 'Close'

    # Sample of program langauge

    # checking validity of user's input:
    is_valid(str_inpt)

    # tokenizing the input for convenient use later:
    tokenized_list = tokenize(str_inpt)

    # starting to work with input:
    classifier(tokenized_list)

# --------------------------------------------Garbage---------------------------------------------------------






    # # Define the parser to generate an Abstract Syntax Tree (AST)
    # def parse(tokens, mem):
    #
    #     if len(tokens) > 1:
    #         mem.factors = tokens.copy()
    #         # while len(tokens):
    #         #     part = tokens.pop(0)
    #         #     if part.isdigit():
    #         #         mem.factors.append(int(part))
    #         #     elif part != ')' and part != '(':
    #         #         mem.operators.append(part)
    #         return
    #
    #     token = tokens.pop(0)
    #     return atom(token)
